# Crea números del 1 al 30 usando el operador “:”
x<-c(1:30)
print(x)
x<-c(1:20)
y<-c(20:1)
z<-c(1:20,20:1)
print(z)
z<-c(1:20,19:1)
print(z)
# Busca en la ayuda que hace la función seq(). Crea una secuencia de números del 1 al 30 con un incremento de 0.5
x<-seq(from=1, to=30, by=0.5)
# Lee los distintos argumentos que pueden utilizar la función seq() para saber que se puede hacer. Después crea una secuencia de 100 números, empezando en el numero 20 y con un incremento del 0.5
x<-seq(from=20, to=100, by=0.5, length=100)
# Lee los distintos argumentos que pueden utilizar la función seq() para saber que se puede hacer. Después crea una secuencia de 100 números, empezando en el numero 20 y con un incremento del 0.5
x<-seq(from=20, to=100,length=100)
# Lee los distintos argumentos que pueden utilizar la función seq() para saber que se puede hacer. Después crea una secuencia de 100 números, empezando en el numero 20 y con un incremento del 0.5
x<-seq(from=20.3, to=100,length=100)
# Lee los distintos argumentos que pueden utilizar la función seq() para saber que se puede hacer. Después crea una secuencia de 100 números, empezando en el numero 20 y con un incremento del 0.5
x<-seq(from=20.5, to=100,length=100)
# Lee los distintos argumentos que pueden utilizar la función seq() para saber que se puede hacer. Después crea una secuencia de 100 números, empezando en el numero 20 y con un incremento del 0.5
x<-seq(from=20, by=0.5 ,length=100)
#Investiga la función rep() con la ayuda. Crea una secuencia que contenga los valores del 1 al 8 repetidos cinco veces.
x<-rep(c(1:8), 5)
# Crea una secuencia que contenga las cuatro primeras letras del abecedario 6 veces.
rep(LETTERS[1:4],times=6)
# Genera un vector x que contenga 9 números comprendidos entre 1 y 5
x<-rep(c(1:5),9)
#Busca que hace la función sequence(). ¿Cual es la diferencia con la función seq()
x<-sequence(from=1, to=30, by=0.5)
#Crea el vector numérico “x” 2.3, 3.3, 4.4 y accede al segundo elemento del vector
x<-c(2.3,3.3,4.4)
print(x[2])
#Crea un vector numérico “z” que contenga del 1 al 10. Cambia la clase del vector forzando que sea de tipo carácter. ¿qué pasa si vuelves a poner z en la terminal?.
z<-c(1:10)
z<-as.character(z)
print(z)
#Ahora cambia el vector z a numérico de nuevo
z<-as.numeric(z)
print(z)
#Crea un vector x con 100 elementos, selecciona de ese vector una muestra al azar de tamaño 5. Quizás quieres averiguar que hace la función sample(). Investiga opciones de extraer valores con y sin remplazo.
x<-seq(from=1, length=100)
sample(x, 5)
muestra<-sample(x, 5)
#Genera un vector de enteros “integer” con 100 números entre el 1 y el 4 de forma aleatoria. Para ello mira en la ayuda la función runif().
x<-runif(100, min=1, max=4)
#Ordena el vector por tamaño usando la función sort(). ¿Qué devuelve la función sort()?
y<-sort(x)
# •	Si quisieras invertir el orden de los elementos del vector que función utilizarías.
z<-rev(y)
#Ahora busca en la ayuda la función order(). Aplicala sobre el vector
# x <- c(2.3, 3.3, 4.4) que hemos generado en los ejercicios anteriores. ¿Cuál es la diferencia con la función sort()?
x<-c(2.3,3.3,4.4)
x<-order(x)
#Ahora busca en la ayuda la función order(). Aplicala sobre el vector
# x <- c(2.3, 3.3, 4.4) que hemos generado en los ejercicios anteriores. ¿Cuál es la diferencia con la función sort()?
x<-c(5.3,3.3,4.4)
x<-order(x)
2
#Ahora busca en la ayuda la función order(). Aplicala sobre el vector
# x <- c(2.3, 3.3, 4.4) que hemos generado en los ejercicios anteriores. ¿Cuál es la diferencia con la función sort()?
x<-c(2.3,3.3,4.4)
x<-order(x)
# La función order devuelve una permutación del orden de los elementos de un vector.
y<-order(v, decreasing = TRUE)
#Ahora busca en la ayuda la función order(). Aplicala sobre el vector
# x <- c(2.3, 3.3, 4.4) que hemos generado en los ejercicios anteriores. ¿Cuál es la diferencia con la función sort()?
x<-c(2.3,3.3,4.4)
y<-order(x)
# La función order devuelve una permutación del orden de los elementos de un vector.
y<-order(x, decreasing = TRUE)
#Crea un vector x que contenga dos veces los números ordenados del 1 al 10. Investiga la función rep(). Una vez comprobado que funciona elimina las entradas repetidas del vector, para ello consulta la función unique().
x<-rep(c(1:10),2)
y<-unique(x)
x <- 1:10
names(x) <- letters[x]
names(x) <- letters[x]
x[1:3]
x[c(1,10)]
x[c(-1,-2)]
x[ x > 5]
x[c("a","d")]
x[]
x <- 1:10; y <- c(x[1:5],99, x[6:10]); y
#Crea un vector x con números del 1 al 100
x<-c(1:100)
#extrae los valores del 2 al 23.
x[2:23]
#Del mismo vector x extrae ahora todos los valores menos del 2:23
x[-2:-23]
#Cambia el número en la posición 5 por el valor 99
x[5]<-99
print(x[5])
#¿Qué devuelve el siguiente comando? letters=="c"
letters=="c"
#¿Qué devuelve el siguiente comando?
which(rep(letters,2)=="c")
#¿Qué devuelve el siguiente comando?
match(c("c","g"), letters)
#Crea un vector x de elementos -5 -1, 0, 1, . . . , 6. Escribe un código en R del tipo x['algo'], para extraer:
x<-c(-5:6)
#elementos de x menores que  0,
x[x<0]
#elementos de x menores o igual que 0,
x[x<=0]
#elementos of x mayor o igual que 3,
x[x>=3]
#elementos de x menor que 0 o mayor que  4
x[x<0 & x>4]
#elementos de x menor que 0 o mayor que  4
x[x<0 & x>4]
x[x<0 | x>4]
#elementos de x mayor que 0 y menor que 4
x[x>0 & x<4]
#elementos de x distintos de 0
x[x!=0]
#El código is.na se usa para identificar valores ausentes (NA). Crea el vector x<- c(1,2,NA) y averigua que pasa cuando escribes is.na(x). Prueba con x[ x!=NA ] ¿obtienes con este comando los “missing values” de x?. ¿cuál es tu explicación?
x<- c(1,2,NA)
is.na(x)
# Devuelve FALSE FALSE  TRUE, pues la tercera posi es NA
x[ x!=NA ]
knitr::opts_chunk$set(echo = TRUE)
x<-c(2.3,3.3,4.4)
x[2]
x<-c(2.3,3.3,4.4)
order(x)
# La función order devuelve una permutación del orden de los elementos de un vector.
order(x, decreasing = TRUE)
# Si estableces el argumento decreasing como TRUE, tendrás el vector de índices en orden descendente.
x<- seq(3,6,0.1)
x<- seq(3,6, by=0.1)
exp(x)*cos(x)
x<- month.name[1:4]
y<- month.name[3:7]
x_y<- intersect(x, y)
x_y
%in%
a <- seq(1,6)
b <- seq(3,10)
a %in% b
a <- seq(1,6)
b <- seq(3,10)
a %in% b
which(a %in% b)
x<- month.name[1:4]
y<- month.name[3:7]
diff(x)
x<- month.name[1:4]
y<- month.name[3:7]
#No es posible aplicarlo con caracteres
#diff(x)
#solucion
diff.Date(x)
x<- month.name[1:4]
y<- month.name[3:7]
#No es posible aplicarlo con caracteres
#diff(x)
#solucion
difftime(x)
x<- month.name[1:4]
y<- month.name[3:7]
#No es posible aplicarlo con caracteres
#diff(x)
#solucion
difftime(x, units = "months")
x<- month.name[1:4]
y<- month.name[3:7]
#No es posible aplicarlo con caracteres
#diff(x)
#solucion
difftime(x, y, units = "auto")
x<- month.name[1:4]
y<- month.name[3:7]
#No es posible aplicarlo con caracteres
diff(x, y)
x<- month.name[1:4]
y<- month.name[3:7]
#No es posible aplicarlo con caracteres
#diff(x, y)
#solucion
difftime(x, y, units = "auto")
a <- seq(1,6)
b <- seq(3,10)
union(a,b)
x<- month.name[1:4]
y<- month.name[3:7]
#No es posible aplicarlo con caracteres
#diff(x, y)
#solucion
difftime(x, y, units = "auto")
a <- seq(1,6)
b <- seq(3,10)
union(a,b)
a <- seq(1,6)
b <- seq(3,10)
union(a,b)
M=matrix(data=5, nr=2, nc=2)
M=matrix(1:6, 2, 3)
M=matrix(1:6, 2, 3, byrow=TRUE)
M=matrix(data=5, nr=2, nc=2)
M
M=matrix(1:6, 2, 3)
M=matrix(1:6, 2, 3, byrow=TRUE)
#se crea una matriz 2x2 con todos los valores igual a 5
M=matrix(data=5, nr=2, nc=2)
M
M=matrix(1:6, 2, 3)
M
M=matrix(1:6, 2, 3, byrow=TRUE)
#se crea una matriz 2x2 con todos los valores igual a 5
M=matrix(data=5, nr=2, nc=2)
M
#se crea una matrz 2x3
M=matrix(1:6, 2, 3)
M
M=matrix(1:6, 2, 3, byrow=TRUE)
M
z<-c(1:30)
matrix(data=z, nrow = 3, ncol = 10)
z<-c(1:30)
M <- matrix(data=z, nrow = 3, ncol = 10)
M
M[,3]
x<- M[,3]
M <- matrix(1:30, 3, 10, byrow = T)
M <- matrix(1:30, 3, 10, byrow = T)
M
M <- matrix(1:30, 3, 10, byrow = T)
M[1,]
M[2,]
M[,2]
M[1,2]
M[,2:3]
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
m1
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
m1
a<-c(1,1)
b<-c(2,2)
rbind(a,b)
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
m1
a<-c(1,1)
b<-c(2,2)
rbind(m1,m2)
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
rbind(m1,m2)
cbind(m1,m2)
#se crea una matriz 2x2 con todos los valores igual a 5
M=matrix(data=5, nr=2, nc=2)
M
#se crea una matrz 2x3 y los valores se asignan por columnas
M=matrix(1:6, 2, 3)
M
#se crea una matrz 2x3 y los valores se asignan por filas
M=matrix(1:6, 2, 3, byrow=TRUE)
M
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
#La diferencia es que rbind una las matrices por
rbind(m1,m2)
cbind(m1,m2)
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
m1 %*% m2
m1 <- matrix(1, nr = 2, nc = 2)
t(m1)
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
#La diferencia es que rbind una las matrices añadiendo filas mientras que cbind las une uniendo columnas
M1<- rbind(m1,m2)
M2<- cbind(m1,m2)
M1
M2
t(M1)
diag(2.1, nr = 3, nc = 5)
diag(rbind(m1, m2) %*% cbind(m1, m2))
diag(m1) <- 10
diag(3)
v <- c(10, 20, 30)
diag(v)
diag(2.1, nr = 3, nc = 5)
matrix(data=c(1,25), 5, 5)
matrix(data=c(1:25), 5, 5)
matrix(data=c(1:25), 5, 5, byrow = T)
#Crea una matriz diagonal con valor de 2.1 en la diagonal
diag(2.1, nr = 3, nc = 5)
#
diag(rbind(m1, m2) %*% cbind(m1, m2))
diag(m1) <- 10
diag(3)
v <- c(10, 20, 30)
diag(v)
diag(2.1, nr = 3, nc = 5)
#Crea una matriz diagonal con valor de 2.1 en la diagonal
diag(2.1, nr = 3, nc = 5)
#
diag(rbind(m1, m2) %*% cbind(m1, m2))
diag(m1) <- 10
diag(3)
v <- c(10, 20, 30)
diag(v)
diag(2.1, nr = 3, nc = 5)
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
m1 %*% m2
t(M1)
#Crea una matriz diagonal con valor de 2.1 en la diagonal
diag(2.1, nr = 3, nc = 5)
#Crea dos nuevas matrices las cuales multiplica mostrando la diagonal generada
rbind(m1, m2) %*% cbind(m1, m2)
diag(m1) <- 10
diag(3)
v <- c(10, 20, 30)
diag(v)
diag(2.1, nr = 3, nc = 5)
#Crea una matriz diagonal con valor de 2.1 en la diagonal
diag(2.1, nr = 3, nc = 5)
#Crea dos nuevas matrices las cuales multiplica mostrando la diagonal generada
diag(rbind(m1, m2) %*% cbind(m1, m2))
diag(m1) <- 10
diag(3)
v <- c(10, 20, 30)
diag(v)
diag(2.1, nr = 3, nc = 5)
#Crea una matriz diagonal con valor de 2.1 en la diagonal
diag(2.1, nr = 3, nc = 5)
#Crea dos nuevas matrices las cuales multiplica mostrando la diagonal generada
diag(rbind(m1, m2) %*% cbind(m1, m2))
#
diag(m1) <- 10
diag(m1)
#crea una matriz diagonal 3x3
diag(3)
v <- c(10, 20, 30)
diag(v)
diag(2.1, nr = 3, nc = 5)
#Crea una matriz diagonal con valor de 2.1 en la diagonal
diag(2.1, nr = 3, nc = 5)
#Crea dos nuevas matrices las cuales multiplica mostrando la diagonal generada
diag(rbind(m1, m2) %*% cbind(m1, m2))
#
diag(m1) <- 10
#crea una matriz diagonal 3x3
diag(3)
v <- c(10, 20, 30)
diag(v)
diag(2.1, nr = 3, nc = 5)
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
diag(m1) <- 10
m1 %*% m2
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
m1
diag(m1) <- 10
m1 %*% m2
m1 <- matrix(1, nr = 2, nc = 2)
m2 <- matrix(2, nr = 2, nc = 2)
m1
diag(m1) <- 10
diag(m1)
m1 %*% m2
i <- array(c(1:5,5:1),dim=c(3,2))
#
dim(i)
nrow(i)
ncol(i)
i <- array(c(1:5,5:1),dim=c(3,2))
i
#
dim(i)
nrow(i)
ncol(i)
v1<- c(1:5)
v2<- c(10:15)
m<- rbind(v1,v2)
m
v1<- c(1:6)
v2<- c(10:15)
m<- rbind(v1,v2)
m
v1<- c(1:5)
v2<- c(10:15)
m<- rbind(v1,v2)
m
